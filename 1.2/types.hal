/******************************************************************************
 *
 *  Copyright 2018-2019 NXP
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************/

package vendor.nxp.hardware.nfc@1.2;

import android.hidl.safe_union@1.0::Monostate;

typedef vec<uint8_t> NfcData;

enum Constants : uint16_t {
    MAX_IOCTL_TRANSCEIVE_CMD_LEN = 256,
    MAX_IOCTL_TRANSCEIVE_RESP_LEN = 256,
    MAX_ATR_INFO_LEN = 128,
    MAX_BUFFER_LEN = 264,
    MAX_VER_INFO_LEN = 2,
    MAX_EMVCO_CMD_LEN = 10,
    NCI_ESE_HARD_RESET_IOCTL = 5,
    HAL_NFC_IOCTL_FIRST_EVT = 0xA0,
};

enum NfcEvent1 : uint8_t {
    HAL_NFC_IOCTL_NCI_TRANSCEIVE = 0xF1,
    HAL_NFC_IOCTL_ESE_HARD_RESET,
};

enum NfcEvent2 : uint8_t {
    HAL_NFC_IOCTL_CHECK_FLASH_REQ = Constants:HAL_NFC_IOCTL_FIRST_EVT,
    HAL_NFC_IOCTL_GET_FEATURE_LIST,
    HAL_NFC_SET_SPM_PWR,
    HAL_NFC_IOCTL_ESE_JCOP_DWNLD,
    HAL_NFC_IOCTL_ESE_UPDATE_COMPLETE,
    HAL_NFC_IOCTL_SET_TRANSIT_CONFIG,
    HAL_NFC_IOCTL_GET_ESE_UPDATE_STATE,
};

enum NfcEvent3 : uint8_t {
    HAL_NFC_POST_MIN_INIT_CPLT_EVT = 0x08,
    HAL_NFC_WRITE_COMPLETE = 0x09,
    HAL_NFC_FW_UPDATE_STATUS_EVT,
};

enum NxpNfcHalStatus : uint8_t {
    HAL_NFC_STATUS_RESTART = 0x30,
    HAL_NFC_HCI_NV_RESET = 0x40,
};

enum NfcFwUpdateStatus : uint8_t {
    HAL_NFC_FW_UPDATE_INVALID = 0x00,
    HAL_NFC_FW_UPDATE_START,
    HAL_NFC_FW_UPDATE_SCUCCESS,
    HAL_NFC_FW_UPDATE_FAILED,
};

struct nfc_nci_ExtnCmd_t {
    uint16_t cmd_len;
    uint8_t[Constants:MAX_IOCTL_TRANSCEIVE_CMD_LEN]  p_cmd;
};

struct nxp_nfc_rfStorage_t {
    uint64_t len;
    uint8_t[Constants:MAX_BUFFER_LEN] path;
};

struct nxp_nfc_fwStorage_t {
    uint64_t len;
    uint8_t[Constants:MAX_BUFFER_LEN] path;
};

struct nxp_nfc_coreConf_t {
    uint64_t len;
    uint8_t[Constants:MAX_BUFFER_LEN] cmd;
};

/*
 * nxp_nfc_scrResetEmvcoCmd_t shall contain core set conf command to reset EMVCO
 * mode and the length of the command
 */
struct nxp_nfc_scrResetEmvcoCmd_t {
    uint64_t len;
    uint8_t[Constants:MAX_EMVCO_CMD_LEN] cmd;
};

/*
 * nxp_nfc_rfFileVerInfo_t shall contain rf file version info and
 * length of it
 */
struct nxp_nfc_rfFileVerInfo_t {
    uint64_t len;
    uint8_t[Constants:MAX_VER_INFO_LEN] ver;
};

/*
 * nxp_nfc_config_t shall contain the respective flag value from the
 * libnfc-nxp.conf
 */
struct nxp_nfc_config_t {
    uint8_t eSeLowTempErrorDelay;
    uint8_t tagOpTimeout;
    uint8_t dualUiccEnable;
    uint8_t defaultAidRoute;
    uint8_t defaultMifareCltRoute;
    uint8_t defautlFelicaCltRoute;
    uint8_t defautlIsoDepRoute;
    uint8_t defaultAidPwrState;
    uint8_t defaultDesfirePwrState;
    uint8_t defaultMifareCltPwrState;
    uint8_t hostListenTechMask;
    uint8_t fwdFunctionalityEnable;
    uint8_t gsmaPwrState;
    uint8_t offHostRoute;
    uint8_t defaultUicc2Select;
    uint8_t smbTransceiveTimeout;
    uint8_t smbErrorRetry;
    uint8_t felicaCltPowerState;
    uint8_t checkDefaultProtoSeId;
    uint8_t nxpLogHalLoglevel;
    uint8_t nxpLogExtnsLogLevel;
    uint8_t nxpLogTmlLogLevel;
    uint8_t nxpLogFwDnldLogLevel;
    uint8_t nxpLogNcixLogLevel;
    uint8_t nxpLogNcirLogLevel;
    uint8_t seApduGateEnabled;
    uint8_t pollEfdDelay;
    uint8_t mergeSakEnable;
    uint8_t stagTimeoutCfg;
    uint8_t t4tNfceePwrState;
    uint8_t scrCfgFormat;
    nxp_nfc_rfStorage_t rfStorage;
    nxp_nfc_fwStorage_t fwStorage;
    nxp_nfc_coreConf_t coreConf;
    nxp_nfc_rfFileVerInfo_t rfFileVersInfo;
    nxp_nfc_scrResetEmvcoCmd_t scrResetEmvco;
};

struct nfc_nci_ExtnRsp_t {
    uint16_t rsp_len;
    uint8_t[Constants:MAX_IOCTL_TRANSCEIVE_RESP_LEN]  p_rsp;
};

struct NxpConfig_t {
    uint64_t len;
    uint8_t[Constants:MAX_BUFFER_LEN] val;
};

struct TransitConfig_t {
    uint64_t len;
    uint8_t[Constants:MAX_BUFFER_LEN] val;
};

safe_union InputData_t {
    Monostate noinit;
    uint16_t bootMode;
    uint8_t halType;
    nfc_nci_ExtnCmd_t nciCmd;
    uint32_t timeoutMilliSec;
    uint64_t nfcServicePid;
    TransitConfig_t transitConfig;
    NxpConfig_t nxpConfig;
};

struct nfc_nci_ExtnInputData_t {
    InputData_t data;
    uint8_t data_source;
    uint64_t level;
};

safe_union outputData_t {
    nxp_nfc_config_t nxpConfigs;
    uint32_t status;
    nfc_nci_ExtnRsp_t nciRsp;
    uint8_t[Constants:MAX_ATR_INFO_LEN] nxpNciAtrInfo;
    uint32_t p61CurrentState;
    uint16_t fwUpdateInf;
    uint16_t fwDwnldStatus;
    uint16_t fwMwVerStatus;
    uint8_t chipType;
};

struct nfc_nci_ExtnOutputData_t {
    uint64_t ioctlType;
    uint32_t result;
    outputData_t data;
};

struct nfc_nci_IoctlInOutData_t {
    nfc_nci_ExtnInputData_t inp;
    nfc_nci_ExtnOutputData_t out;
};

safe_union nfcIoctlData_t {
    Monostate noinit;
    uint8_t ese_jcop_download_state;
};
